---
title: "Evolución de los elementos"
author: "Santiago Garcia-Rios"
format:
  html:
    grid: 
      body-width: 1300px
    resources: 
      - shinylive-sw.js
filters:
  - shinylive
---

## Demostración

Este es un ejemplo de aplicación de R que muestra un histograma de una muestra aleatoria de una distribución normal. La línea roja representa la media de la distribución normal y la línea azul representa la media de la muestra.



## Demostración

Este es un ejemplo de aplicación de R que muestra un histograma de una muestra aleatoria de una distribución normal. La línea roja representa la media de la distribución normal y la línea azul representa la media de la muestra.

```{shinylive-r}
#| standalone: true
#| viewerHeight: 600
# Cargar las librerías necesarias
# Cargar las librerías necesarias
library(shiny)
library(ggplot2)
library(gapminder)
library(leaflet)
library(dplyr)
library(maps)

# Cargar los datos de Gapminder
data("gapminder")

# Obtener las coordenadas de los países usando el paquete maps
world_coords <- map_data("world") %>%
  group_by(region) %>%
  summarise(long = mean(long), lat = mean(lat))

# Renombrar la columna "region" a "country" para que coincida con gapminder
colnames(world_coords)[1] <- "country"

# Combinar los datos de gapminder con las coordenadas
gapminder <- gapminder %>%
  left_join(world_coords, by = "country")

# Definir la interfaz de usuario (UI)
ui <- fluidPage(
  titlePanel("Visualización de Datos de Gapminder"),
  
  sidebarLayout(
    sidebarPanel(
      # Control deslizante para seleccionar el año
      sliderInput("year", "Selecciona el año:", 
                  min = min(gapminder$year), 
                  max = max(gapminder$year), 
                  value = min(gapminder$year), 
                  step = 1, 
                  animate = TRUE),
      
      # Selector de país para el mapa
      selectInput("country", "Selecciona un país:", 
                  choices = unique(gapminder$country))
    ),
    
    mainPanel(
      # Gráfico de Expectativa de vida vs GDP
      plotOutput("lifeExp_vs_gdp"),
      
      # Mapa interactivo
      leafletOutput("map")
    )
  )
)

# Definir el servidor
server <- function(input, output) {
  
  # Filtrar los datos según el año seleccionado
  filtered_data <- reactive({
    gapminder %>% filter(year == input$year)
  })
  
  # Gráfico de Expectativa de vida vs GDP
  output$lifeExp_vs_gdp <- renderPlot({
    ggplot(filtered_data(), aes(x = gdpPercap, y = lifeExp, color = continent)) +
      geom_point(alpha = 0.7) +
      scale_x_log10() +
      labs(title = paste("Expectativa de vida vs GDP en el año", input$year),
           x = "GDP per cápita (log scale)",
           y = "Expectativa de vida") +
      theme_minimal()
  })
  
  # Mapa interactivo
  output$map <- renderLeaflet({
    # Filtrar los datos del país seleccionado
    country_data <- gapminder %>% filter(country == input$country)
    
    # Verificar si hay coordenadas disponibles para el país seleccionado
    if (is.na(country_data$long) || is.na(country_data$lat)) {
      # Si no hay coordenadas, mostrar un mensaje en el mapa
      leaflet() %>%
        addTiles() %>%
        addMarkers(lng = 0, lat = 0, popup = "Coordenadas no disponibles para este país.")
    } else {
      # Si hay coordenadas, mostrar el país en el mapa
      leaflet(country_data) %>%
        addTiles() %>%
        addMarkers(lng = ~long, lat = ~lat, 
                   popup = ~paste("País: ", country, "<br>",
                                  "Expectativa de vida: ", lifeExp, "<br>",
                                  "GDP per cápita: ", gdpPercap))
    }
  })
}

# Ejecutar la aplicación Shiny
shinyApp(ui = ui, server = server)
```



::: {.panel-tabset}
## Similarity between the chemical elements

> Chemical elements show resemblances to others in the compounds they form. Two elements are alike if they both form compounds with similar compositions.

> This similarity matrix encodes how similar each element is to any other one.

*Hover over any pixel to visualize the similarity between a pair of elements*


## Optimize the sequence of element

> Similarity information can be encoded in a sequence of elements, so that similar elements are closer together.

> Using genetic algorithms, we find such optimal sequences.

**Press the button to optimize the sequence.**

- This will bring high values of the matrix closer to the diagonal.

:::



